---
title: NIO
category: ['NIO']
tags: ['NIO']
author: 景阳
email: jyjsjd@hotmail.com
description: NIO
typora-root-url: ../../jyjsjd.github.io
---

## 1. 缓冲区

### 1.1 属性：

- 容量（Capacity）：缓冲区能够容纳的数据元素的最大数量。这一容量在缓冲区创建时被设定，并且永远不能被改变。
- 上界（Limit）：缓冲区的第一个不能被读或写的元素。或者说，缓冲区中现存元素的计数。
- 位置（Position）：下一个要被读或写的元素的索引。位置会自动由相应的 *get()*和 *put()*函数更新。 
- 标记（Mark）：一个备忘位置。调用*mark()*来设定mark=postion。调用*reset()*设定*position=mark*。标记在设定前是未定义的（undefined）。

属性遵守以下规则：

```0 <= mark <= position <= limit <= capacity```

### 1.2 继承体系

![buffer](/assets/img/buffer.png)

### 1.3 方法签名

```java
public abstract class Buffer {
    public final int capacity();
    public final int position();
    public final Buffer position(int newPosition);
    public final int limit();
    public final Buffer limit(int newLimit);
    /**
     * 标记使缓冲区能够记住一个位置
     **/
    public final Buffer mark();
    /**
     * 返回到一个先前设定的标记
     **/
    public final Buffer reset();
    /**
     * 清空缓冲区
     **/
    public final Buffer clear();
    /**
     * 将缓冲区翻转两次大小会变为 0
     **/
    public final Buffer flip();
    /**
     * rewind 和 flip 相似，但不会影响 limit 属性
     **/
    public final Buffer rewind();
    public final int remaining();
    public final boolean hasRemaining();
    /**
     * 所有的缓冲区都是可读的，但并非所有都可写。
     **/
    public abstract boolean isReadOnly();
}
```

#### 压缩

```java
public abstract class ByteBuffer extends Buffer implements Comparable {
		public abstract ByteBuffer compact( ); 
}
```

压缩前：

![compactbefore](/assets/img/compactbefore.png)

压缩后：

![compactafter](/assets/img/compactafter.png)

### 1.4 创建缓冲区

新的缓冲区是由分配或包装操作创建的：

- **分配**操作（allocate）创建一个缓冲区对象并分配一个私有的空间来储存容量大小的数据元素。
- **包装**操作（wrap）创建一个缓冲区对象但是不分配任何空间来储存数据元素。

```java
public abstract class CharBuffer extends Buffer implements CharSequence, Comparable {
    public static CharBuffer allocate(int capacity);
    public static CharBuffer wrap(char[] array);
    public static CharBuffer wrap(char[] array, int offset, int length);
    public final boolean hasArray();
    public final char[] array();
    public final int arrayOffset();
}
```

### 1.5 批量移动

```java
public abstract class CharBuffer extends Buffer implements CharSequence, Comparable {
    public CharBuffer get(char[] dst);
    public CharBuffer get(char[] dst, int offset, int length);
    public final CharBuffer put(char[] src);
    public CharBuffer put(char[] src, int offset, int length);
    public CharBuffer put(CharBuffer src);
    public final CharBuffer put(String src);
    public CharBuffer put(String src, int start, int end);
}
```

### 1.6 复制缓冲区

```java
public abstract class CharBuffer extends Buffer implements CharSequence, Comparable {
    /**
     * 创建了一个与原始缓冲区相似的新缓冲区。两个缓冲区共享数据元素，拥有同样的容量，但每个缓冲区拥有各自的位置，上界和标记属性。对一个缓冲区内的数据元素所做的改变会反映在另外一个缓冲区上。
     */
    public abstract CharBuffer duplicate();
    /**
     * 生成一个只读的缓冲区视图。这与 duplicate()相同，除了这个新的缓冲区不允许使用 put()，并且其 isReadOnly()函数 将会返回true。
     */
    public abstract CharBuffer asReadOnlyBuffer();
    /**
     * 创建一个从原始缓冲区的当前位置开始的新缓冲区，并且其容量是原始缓冲区的剩余元素数量(limit-position)。这个新缓冲区与原始缓冲区共享一段数据元素子序列。
     */
    public abstract CharBuffer slice();
}
```

### 1.7 比较

两个缓冲区被认为相等的充要条件是：

- 两个对象**类型相同**。包含不同数据类型的buffer永远不会相等。
- 两个对象都**剩余同样数量的元素**。Buffer 的容量不需要相同，而且缓冲区中剩余数据的索引也不必相同，但每个缓冲区中剩余元素的数目（从 *position* 到 *limit*）必须相同。
- 在每个缓冲区中应被 get( )函数返回的剩余数据元素序列必须一致。

## 2. 通道

Channel 用于在字节缓冲区和位于通道另一侧的实体（通常是一个文件或套接字）之间有效地传输数据。通道分为**文件通道**和**套接字通道**。

```java
public interface Channel extends Closeable {
  	/**
  	 * 判断通道是否打开
  	 **/
    public boolean isOpen();
  	/**
  	 * 关闭通道
  	 **/
    public void close() throws IOException;
}
```

### 2.1 继承体系

![channel](/assets/img/channel.png)

#### 2.1.1 打开关闭通道

```java
SocketChannel sc = SocketChannel.open();
sc.connect (new InetSocketAddress ("somehost", someport));
ServerSocketChannel ssc = ServerSocketChannel.open( );
ssc.socket().bind (new InetSocketAddress (somelocalport));
DatagramChannel dc = DatagramChannel.open();
RandomAccessFile raf = new RandomAccessFile ("somefile", "r");
FileChannel fc = raf.getChannel();
```

#### 2.1.2 单向通道和双向通道

通道可以是**单向**（*unidirectional*）或者**双向**的（*bidirectional*）。一个 channel 类可能实现定义 *read( )*方法的 *ReadableByteChannel* 接口，也可以实现 *WritableByteChannel* 接口以提供 *write( )*方法。实现这两种接口其中之一的类都是单向的，只能在一个方向上传输数据。如果一个类同时实现这两个接口，那么它是双向的，可以双向传输数据。

- `ReadableByteChannel` 
- `WritableByteChannel`

#### 2.1.3 可中断通道

如果一个通道实现 *InterruptibleChannel* 接口，它的行为以下述语义为准：

- 如果一个线程在一个通道上被阻塞并且同时被中断（由调用该被阻塞线程的 *interrupt()*方法的另一个线程中断），那么该通道将被关闭，该被阻塞线程也会产生一个 *ClosedByInterruptException* 异常。
- 假如一个线程的 *interrupt status* 被设置并且该线程试图访问一个通道，那么这个通道将立即被关闭，同时将抛出相同的 *ClosedByInterruptException* 异常。

#### 2.1.4 SelectableChannel

通道可以以阻塞（*blocking*）或非阻塞（*nonblocking*）模式运行。非阻塞模式的通道永远不会让调用的线程休眠。请求的操作要么立即完成，要么返回一个结果表明未进行任何操作。

```java
public abstract class SelectableChannel extends 
    AbstractInterruptibleChannel implements Channel {
    public abstract SelectableChannel configureBlocking(boolean block) throws IOException;
}
```

### 2.2 矢量 IO

矢量 IO 是指在多个缓冲区上实现的 I/O 操作：

- ScatteringByteChannel：对于一个 *write* 操作而言，数据是从几个缓冲区按顺序抽取（称为 *gather*）并沿着通道发送的。*gather* 过程的效果就好比全部缓冲区的内容被连结起来，并在发送数据前存放到一个大的缓冲区中。
- GatheringByteChannel：对于 *read* 操作而言，从通道读取的数据会按顺序被散布（称为 *scatter*）到多个缓冲区，将每个缓冲区填满直至通道中的数据或者缓冲区的最大空间被消耗完。

### 2.3 FileChannel

- 文件通道总是阻塞式的。
- *FileChannel*实例只能通过在一个 打开的 file 对象（*RandomAccessFile*、*FileInputStream*或 *FileOutputStream*）上调用 *getChannel()* 方法获取。
- *FileChannel* 对象是线程安全（thread-safe）的。

### 2.4 Socket 通道

Socket 通道可以在非阻塞模式下运行。

#### 2.4.1 ServerSocketChannel

*ServerSocketChannel* 负责监听传入的连接和创建新的 *SocketChannel* 对象，它本身不传输数据。

```java
public abstract class ServerSocketChannel extends AbstractSelectableChannel implements NetworkChannel {
    protected ServerSocketChannel(SelectorProvider provider) {
        super(provider);
    }
  	/**
  	 * 创建一个新的 ServerSocketChannel 对象，将会返回同一个未绑定的 ServerSocket 关联的通道。
  	 **/
    public static ServerSocketChannel open() throws IOException {
        return SelectorProvider.provider().openServerSocketChannel();
    }
    public final int validOps() {
        return SelectionKey.OP_ACCEPT;
    }
  	/**
  	 * 绑定到一个端口以开始监听连接
  	 **/
    public final ServerSocketChannel bind(SocketAddress local) throws IOException {
        return bind(local, 0);
    }
    public abstract ServerSocketChannel bind(SocketAddress local, int backlog) throws IOException;
    public abstract <T> ServerSocketChannel setOption(SocketOption<T> name, T value) throws IOException;
    public abstract ServerSocket socket();
    public abstract SocketChannel accept() throws IOException;
    @Override
    public abstract SocketAddress getLocalAddress() throws IOException;
}
```

#### 2.4.2 SocketChannel

#### 2.4.3 DatagramChannel

## 3. 选择器

![selectionkey](/assets/img/selectionkey.png)

### Selector

### SelectionKey