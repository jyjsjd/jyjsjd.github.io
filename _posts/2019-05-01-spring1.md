---
title: Spring
category: ['Spring']
tags: ['Spring']
author: 景阳
email: jyjsjd@hotmail.com
description: Spring
typora-root-url: ../../jyjsjd.github.io
---

## 1. 类的定义

![beandefinition](/assets/img/beandefinition.png)

### BeanDefinition

#### RootBeanDefinition

类的定义

### BeanDefinitionRegistry

管理 *BeanDefinition*

```java
public interface BeanDefinitionRegistry extends AliasRegistry {
	void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)
			throws BeanDefinitionStoreException;
	void removeBeanDefinition(String beanName) throws NoSuchBeanDefinitionException;
	BeanDefinition getBeanDefinition(String beanName) throws NoSuchBeanDefinitionException;
	boolean containsBeanDefinition(String beanName);
	String[] getBeanDefinitionNames();
	int getBeanDefinitionCount();
	boolean isBeanNameInUse(String beanName);
}
```

*DefaultListableBeanFactory* 实现了 *BeanDefinitionRegistry*：

```java
  /** Map from dependency type to corresponding autowired value */
	private final Map<Class<?>, Object> resolvableDependencies = new ConcurrentHashMap<Class<?>, Object>(16);

	/** BeanDefinition 的 map，key 是 bean name */
	private final Map<String, BeanDefinition> beanDefinitionMap = new ConcurrentHashMap<String, BeanDefinition>(256);

	/** Map of singleton and non-singleton bean names, keyed by dependency type */
	private final Map<Class<?>, String[]> allBeanNamesByType = new ConcurrentHashMap<Class<?>, String[]>(64);

	/** Map of singleton-only bean names, keyed by dependency type */
	private final Map<Class<?>, String[]> singletonBeanNamesByType = new ConcurrentHashMap<Class<?>, String[]>(64);

	/** List of bean definition names, in registration order */
	private volatile List<String> beanDefinitionNames = new ArrayList<String>(256);

	/** List of names of manually registered singletons, in registration order */
	private volatile Set<String> manualSingletonNames = new LinkedHashSet<String>(16);
```

### ConstructorArgumentValues

构造器注入

### MutablePropertyValues

setter 注入

### BeanDefinitionReader

读取解析 Bean 的定义

## 2. Environment

### 2.1 Environment

代表当前的环境，主要和 *profile*、*property* 相关。

注意 *PropertyResolver* 中关于 property 的方法和 *Environment* 中关于 profile 的方法。

![environment](/assets/img/environment.png)

### 2.2. PropertySource

![propertysource](/assets/img/propertysource.png)

```java
public interface PropertySources extends Iterable<PropertySource<?>> {
	boolean contains(String name);
	PropertySource<?> get(String name);
}
```

### 2.3 PropertySources

存放 property 的容器。

![propertysources](/assets/img/propertysources.png)

```java
public interface PropertySources extends Iterable<PropertySource<?>> {
	boolean contains(String name);
	PropertySource<?> get(String name);
}
```

### 2.4 PropertyResolver

解析 property。

![propertyresolver](/assets/img/propertyresolver.png)

### 2.5 初始化

*AbstractApplicationContext* 中：

```java
protected void prepareRefresh() {
		// Switch to active.
		this.startupDate = System.currentTimeMillis();
		this.closed.set(false);
		this.active.set(true);

		if (logger.isInfoEnabled()) {
			logger.info("Refreshing " + this);
		}

		// 初始化 property
		initPropertySources();

		// Validate that all properties marked as required are resolvable:
		// see ConfigurablePropertyResolver#setRequiredProperties
		getEnvironment().validateRequiredProperties();

		// Allow for the collection of early ApplicationEvents,
		// to be published once the multicaster is available...
		this.earlyApplicationEvents = new LinkedHashSet<ApplicationEvent>();
	}
```

## 3. BeanFactory

### 继承体系

![beanfactory1](/assets/img/beanfactory1.png)

### HierarchicalBeanFactory

应用中可以有多个 *BeanFactory*，各个 *BeanFactory* 可以是父子关系。

```java
public interface HierarchicalBeanFactory extends BeanFactory {
	BeanFactory getParentBeanFactory();
	boolean containsLocalBean(String name);
}
```

### ListableBeanFactory

通过 *ListableBeanFactory*，可以获取多个 *Bean*。

```java
public interface ListableBeanFactory extends BeanFactory {
	boolean containsBeanDefinition(String beanName);
	int getBeanDefinitionCount();
	String[] getBeanDefinitionNames();
	String[] getBeanNamesForType(ResolvableType type);
	String[] getBeanNamesForType(Class<?> type);
	String[] getBeanNamesForType(Class<?> type, boolean includeNonSingletons, boolean allowEagerInit);
	<T> Map<String, T> getBeansOfType(Class<T> type) throws BeansException;
	<T> Map<String, T> getBeansOfType(Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)
			throws BeansException;
	String[] getBeanNamesForAnnotation(Class<? extends Annotation> annotationType);
	Map<String, Object> getBeansWithAnnotation(Class<? extends Annotation> annotationType) throws BeansException;
	<A extends Annotation> A findAnnotationOnBean(String beanName, Class<A> annotationType)
			throws NoSuchBeanDefinitionException;
}
```

### AutowireCapableBeanFactory

```java
public interface AutowireCapableBeanFactory extends BeanFactory {
	int AUTOWIRE_NO = 0;
	int AUTOWIRE_BY_NAME = 1;
	int AUTOWIRE_BY_TYPE = 2;
	int AUTOWIRE_CONSTRUCTOR = 3;
	@Deprecated
	int AUTOWIRE_AUTODETECT = 4;
	//-------------------------------------------------------------------------
	// Typical methods for creating and populating external bean instances
	//-------------------------------------------------------------------------
	<T> T createBean(Class<T> beanClass) throws BeansException;
	void autowireBean(Object existingBean) throws BeansException;
	Object configureBean(Object existingBean, String beanName) throws BeansException;

	//-------------------------------------------------------------------------
	// Specialized methods for fine-grained control over the bean lifecycle
	//-------------------------------------------------------------------------
	Object createBean(Class<?> beanClass, int autowireMode, boolean dependencyCheck) throws BeansException;
	Object autowire(Class<?> beanClass, int autowireMode, boolean dependencyCheck) throws BeansException;
	void autowireBeanProperties(Object existingBean, int autowireMode, boolean dependencyCheck)
			throws BeansException;
	void applyBeanPropertyValues(Object existingBean, String beanName) throws BeansException;
	Object initializeBean(Object existingBean, String beanName) throws BeansException;
	Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName)
			throws BeansException;
	Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName)
			throws BeansException;
	void destroyBean(Object existingBean);
	//-------------------------------------------------------------------------
	// Delegate methods for resolving injection points
	//-------------------------------------------------------------------------
	<T> NamedBeanHolder<T> resolveNamedBean(Class<T> requiredType) throws BeansException;
	Object resolveDependency(DependencyDescriptor descriptor, String requestingBeanName) throws BeansException;
	Object resolveDependency(DependencyDescriptor descriptor, String requestingBeanName,
			Set<String> autowiredBeanNames, TypeConverter typeConverter) throws BeansException;
}
```

### DefaultListableBeanFactory

### 

## 4. ApplicationContext

![applicationcontext1](/assets/img/applicationcontext1.png)

### AbstractRefreshableApplicationContext

持有一个 `DefaultListableBeanFactory：

```java
public abstract class AbstractRefreshableApplicationContext extends AbstractApplicationContext {
	private DefaultListableBeanFactory beanFactory;
  
	public AbstractRefreshableApplicationContext(ApplicationContext parent) {
		super(parent);
	}
}
```

### AbstractXmlApplicationContext

解析 XML 文件

```java
public abstract class AbstractXmlApplicationContext extends AbstractRefreshableConfigApplicationContext {
    protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException {
        XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);
        beanDefinitionReader.setEnvironment(this.getEnvironment());
        beanDefinitionReader.setResourceLoader(this);
        beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));
        this.initBeanDefinitionReader(beanDefinitionReader);
        this.loadBeanDefinitions(beanDefinitionReader);
    }
}
```

初始化：

```java
@Override
	public void refresh() throws BeansException, IllegalStateException {
		synchronized (this.startupShutdownMonitor) {
			// Prepare this context for refreshing.
			prepareRefresh();

			// Tell the subclass to refresh the internal bean factory.
			ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

			// Prepare the bean factory for use in this context.
			prepareBeanFactory(beanFactory);

			try {
				// Allows post-processing of the bean factory in context subclasses.
				postProcessBeanFactory(beanFactory);

				// Invoke factory processors registered as beans in the context.
				invokeBeanFactoryPostProcessors(beanFactory);

				// Register bean processors that intercept bean creation.
				registerBeanPostProcessors(beanFactory);

				// Initialize message source for this context.
				initMessageSource();

				// Initialize event multicaster for this context.
				initApplicationEventMulticaster();

				// Initialize other special beans in specific context subclasses.
				onRefresh();

				// Check for listener beans and register them.
				registerListeners();

				// Instantiate all remaining (non-lazy-init) singletons.
				finishBeanFactoryInitialization(beanFactory);

				// Last step: publish corresponding event.
				finishRefresh();
			}

			catch (BeansException ex) {
				if (logger.isWarnEnabled()) {
					logger.warn("Exception encountered during context initialization - " +
							"cancelling refresh attempt: " + ex);
				}

				// Destroy already created singletons to avoid dangling resources.
				destroyBeans();

				// Reset 'active' flag.
				cancelRefresh(ex);

				// Propagate exception to caller.
				throw ex;
			}

			finally {
				// Reset common introspection caches in Spring's core, since we
				// might not ever need metadata for singleton beans anymore...
				resetCommonCaches();
			}
		}
	}
```



### ClassPathXmlApplicationContext



## 2. 实例化

## InstantiationStrategy

![instantiationstrategy](/assets/img/instantiationstrategy.png)

### SimpleInstantiationStrategy

### CglibSubclassingInstantiationStrategy

### BeanWrapper



## 7. LifeCycle



## 工具类

### ApplicationContextAwareProcessor

自动注入 `applicationContext`：

```java
class ApplicationContextAwareProcessor implements BeanPostProcessor {
	private final ConfigurableApplicationContext applicationContext;
	private final StringValueResolver embeddedValueResolver;

	public ApplicationContextAwareProcessor(ConfigurableApplicationContext applicationContext) {
		this.applicationContext = applicationContext;
		this.embeddedValueResolver = new EmbeddedValueResolver(applicationContext.getBeanFactory());
	}
}
```

### BeanFactoryPostProcessor

#### PropertyPlaceholderConfigurer

替换占位符

对 􏴉􏲄􏱝BeanDefinition􏱙􏰆􏷤􏻹􏳙􏳘􏴮􏵆􏳌􏻃􏵕􏴲 􏰙􏰭􏰆的数据进行修改

#### PropertyOverrideConfigurer

覆盖占位符

对 􏴉􏲄􏱝BeanDefinition􏱙􏰆􏷤􏻹􏳙􏳘􏴮􏵆􏳌􏻃􏵕􏴲 􏰙􏰭􏰆的数据进行修改

#### CustomEditorConfigurer

􏱦􏵔􏱖􏲣􏰞􏵕􏰆􏰂􏴬􏷬􏰅􏵕􏰌􏶑将后期会用到的数据注册到容器

